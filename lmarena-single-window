(function() {
    // 1. Helpers
    function toXmlTag(name) {
        return name.toLowerCase().replace(/[^a-z0-9]/g, '_').replace(/^_+|_+$/g, '') || 'assistant';
    }

    const processedElements = new WeakSet(); // THE KEY: Guarantees we never parse the same HTML block twice

    function tableToMarkdown(tableEl) {
        const rows = Array.from(tableEl.querySelectorAll('tr'));
        let md = "";
        rows.forEach((row, index) => {
            const cells = Array.from(row.querySelectorAll('th, td'));
            const cellTexts = cells.map(c => c.innerText.trim().replace(/\n/g, ' '));
            md += `| ${cellTexts.join(' | ')} |\n`;
            if (index === 0) md += `| ${cellTexts.map(() => '---').join(' | ')} |\n`;
        });
        return md + "\n";
    }

    function listToMarkdown(listEl) {
        const items = Array.from(listEl.children).filter(el => el.tagName === 'LI');
        const isOrdered = listEl.tagName === 'OL';
        let md = "";
        items.forEach((li, index) => {
            md += `${isOrdered ? (index + 1) + '. ' : '- '}${li.innerText.trim()}\n`;
        });
        return md + "\n";
    }

    function parseProse(container) {
        const prose = container.querySelector('.prose');
        if (!prose) return "";
        
        let textPart = "";
        Array.from(prose.children).forEach(child => {
            const tag = child.tagName;
            const table = tag === 'TABLE' ? child : child.querySelector('table');
            if (table) {
                textPart += tableToMarkdown(table);
            } else if (tag === 'UL' || tag === 'OL') {
                textPart += listToMarkdown(child);
            } else if (tag === 'PRE' || child.querySelector('code')) {
                const lang = child.querySelector('.text-text-secondary')?.innerText || "code";
                const code = child.querySelector('code')?.innerText || child.innerText;
                textPart += "```" + lang + "\n" + code.trim() + "\n```\n\n";
            } else if (tag.startsWith('H')) {
                textPart += "#".repeat(parseInt(tag[1]) || 1) + " " + child.innerText.trim() + "\n\n";
            } else {
                const text = child.innerText.trim();
                if (text) textPart += text + "\n\n";
            }
        });
        return textPart;
    }

    // 2. Setup
    const timestamp = new Date().toLocaleString();
    let output = `# Chatbot Arena Export - ${timestamp}\n\n`;

    // 3. Find the main chat container
    const chatList = document.querySelector('ol.flex-col-reverse') || document.querySelector('ol');
    if (!chatList) return console.error("Chat list not found.");

    // Chronological order (Arena uses flex-col-reverse, so we reverse the list)
    const turns = Array.from(chatList.children).reverse();

    turns.forEach((turn) => {
        // --- STEP A: Look for User Message ---
        const userBox = turn.querySelector('.bg-surface-raised');
        if (userBox && !processedElements.has(userBox)) {
            const userText = userBox.querySelector('.prose')?.innerText.trim() || userBox.innerText.trim();
            output += `## USER\n${userText}\n\n---\n\n`;
            processedElements.add(userBox);
        }

        // --- STEP B: Look for Assistant Response(s) ---
        // In Battle Mode, there might be 2 .bg-surface-primary blocks side-by-side
        const assistantBlocks = Array.from(turn.querySelectorAll('.bg-surface-primary'));
        
        assistantBlocks.forEach((block) => {
            // Check if this specific block was already handled (carousel clones)
            if (processedElements.has(block)) return;

            const rawModelName = block.querySelector('.truncate')?.innerText.trim() || "Assistant";
            const proseContent = parseProse(block);
            
            // Skip empty boxes (sometimes the Arena has empty placeholder divs)
            if (!proseContent && !block.querySelector('button[aria-controls^="radix-"]')) return;

            const tagName = toXmlTag(rawModelName);
            output += `### ${rawModelName}\n<${tagName}>\n\n`;

            // Thinking Trace
            const thinkBtn = block.querySelector('button[aria-controls^="radix-"]');
            if (thinkBtn) {
                const id = thinkBtn.getAttribute('aria-controls');
                const thinkDiv = document.getElementById(id);
                if (thinkDiv) {
                    const trace = thinkDiv.innerText.replace(/Thought for \d+ seconds/i, '').trim();
                    if (trace) output += `<thinking>\n${trace}\n</thinking>\n\n`;
                }
            }

            output += proseContent;
            output += `</${tagName}>\n\n---\n\n`;
            
            processedElements.add(block);
        });
    });

    // 4. Final Save
    const blob = new Blob([output], { type: 'text/markdown' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `LMArena_Universal_Export_${Date.now()}.md`;
    a.click();
    URL.revokeObjectURL(a.href);
})();
